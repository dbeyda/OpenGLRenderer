#shader vertex#version 410 corelayout(location = 0) in vec4 position;layout(location = 1) in vec4 normal;layout(location = 2) in vec2 texCoord;layout(location = 3) in vec3 tangent;out vec4 ambient;out vec2 fragTexCoord;out vec4 fragNormal;out vec4 pos;out vec3 fragTangent;uniform mat4 u_MVP;uniform float u_ambientStrength;uniform vec4 u_ambientLightColor;uniform mat4 u_invTransMV;void main(){    gl_Position = u_MVP * position;    fragTexCoord = texCoord;    ambient = u_ambientStrength * u_ambientLightColor;    ambient.a = 1.0f;    fragNormal = normalize(normal);    pos = position;    fragTangent = tangent;};#shader fragment#version 410 corein vec4 ambient;in vec2 fragTexCoord;in vec4 fragNormal;in vec4 pos;in vec3 fragTangent;layout(location = 0) out vec4 color;uniform sampler2D AmbientTexture;uniform sampler2D DiffuseTexture;uniform sampler2D BumpTexture;uniform float u_ka;uniform float u_kd;uniform float u_kc;uniform float u_kl;uniform float u_kq;uniform int u_ilum;uniform int u_sexp;uniform float u_mshi;uniform float u_ks;uniform mat4 u_invTransMV;uniform mat4 u_MV;uniform bool u_hasAmbientTexture;uniform bool u_hasDiffuseTexture;uniform bool u_hasBumpTexture;vec3 expand(vec3 v){    return (v - 0.5) * 2;}void main(){    // TBN matrix    vec3 T = normalize(mat3(u_MV) * normalize(fragTangent.xyz));    vec3 N = normalize(mat3(u_MV) * normalize(fragNormal.xyz));    vec3 B = normalize(cross(N, T));    mat3 TBN = mat3(T, B, N);    // calculating light direction in camera space    vec3 mvEye = vec3(0, 0, 0);    vec3 mvPos = vec3(u_MV * normalize(pos));    vec3 mvLight = normalize(mvEye - mvPos);    // calculating normal in camera space    vec3 mvNormal;    if (u_hasBumpTexture)    {        vec3 bumpNormal = expand(texture(BumpTexture, fragTexCoord).xyz);        mvNormal = normalize(TBN * bumpNormal);    }    else        mvNormal = normalize(vec3(u_invTransMV * vec4(fragNormal.xyz, 0)));    // calculating lighting properties in camera space    float d = distance(vec4(0, 0, 0, 1), u_MV * pos);    float katt = 1 / (u_kc + u_kl * d + u_kq * d * d);    float kspot = pow(max(dot(-mvLight, vec3(0, 0, -1)), 0), u_sexp);    // diffuse lighting in camera space    float difIntensity = (mvLight.z > 0) ? (u_ka + u_kd * max(dot(mvNormal, mvLight), 0.0)) : 0;    vec4 diffuse = vec4(difIntensity);    if (u_hasDiffuseTexture)        diffuse *= texture(DiffuseTexture, fragTexCoord);    //diffuse.w = 1.0; ??        vec4 ambientFinal = vec4(ambient);    if (u_hasAmbientTexture)        ambientFinal = texture(AmbientTexture, fragTexCoord) * ambientFinal;    // specular lighting in camera space    /*        Calculated using ispec = (normal*h)^mshi; where h = normalize(lightDir + viewerDir).        Here, however, as the lighting is coming from the camera, lightDir = viewerDir = h;        thus, ispec = pow(max(dot(normal, h), 0), u_mshi) becomes        ispec = pow(max(dot(normal, lightDir), 0), u_mshi)    */    float specular = 0;    if (mvLight.z > 0 && dot(mvNormal, mvLight) > 0 && u_ilum == 2)        specular = u_ks * pow(max(dot(mvNormal, mvLight), 0), u_mshi);    color = ambientFinal + (diffuse + specular) * katt * kspot;    // color.w = 1.0; ??};