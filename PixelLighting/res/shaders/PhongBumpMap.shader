#shader vertex#version 410 corelayout(location = 0) in vec4 position;   /* vertex position */layout(location = 1) in vec4 normal;     /* vertex normal   */layout(location = 2) in vec2 texCoord;   /* vertex texture coordinate */layout(location = 3) in vec3 tangent;    /* vertex tangent (calculated on obj load) */uniform mat4 u_MVP;                      /* object MVP matrix */uniform vec4 u_globalLightColor;         /* global light color */uniform float u_globalLightStrength;     /* global light strength */out vec4 pos;                            /* vertex position */out vec4 fragNormal;                     /* vertex normal */out vec2 fragTexCoord;                   /* vertex texture coordinate */out vec3 fragTangent;                    /* vertex tangent */out vec4 globalLight;                    /* global light component */void main(){    pos = position;    fragNormal = normalize(normal);    fragTexCoord = texCoord;    fragTangent = tangent;    globalLight = u_globalLightStrength * u_globalLightColor;    globalLight.a = 1;        gl_Position = u_MVP * position;};#shader fragment#version 410 corein vec4 pos;                             /* interpolated vertex position */in vec4 fragNormal;                      /* interpolated vertex normal */in vec2 fragTexCoord;                    /* interpolated vertex texture coordinate */in vec3 fragTangent;                     /* interpolated vertex tangent */in vec4 globalLight;                     /* global light component */// texture samplersuniform sampler2D AmbientTexture;        /* sampler for material map_ka */uniform sampler2D DiffuseTexture;        /* sampler for material map_kd */uniform sampler2D BumpTexture;           /* sampler for material map_bump */// texture flagsuniform bool u_hasAmbientTexture;        /* true when material has map_ka */uniform bool u_hasDiffuseTexture;        /* true when material has map_kd */uniform bool u_hasBumpTexture;           /* true when material has map_bump */// material propertiesuniform float u_mshi;                    /* material shiness */uniform float u_ka;uniform float u_ks;uniform float u_kd;// light propertiesuniform vec3 u_mvLightPos;               /* light position in Camera Space */uniform float u_kc;                      /* constant term for katt */uniform float u_kl;                      /* linear term for katt */uniform float u_kq;                      /* quadratic term for katt */uniform int u_sexp;                      /* spotlight beam angle exponent*/uniform vec3 u_mvSpotLightDir;// transformation matricesuniform mat4 u_MV;                       /* object model view matrix */uniform mat4 u_invTransMV;               /* inverse transpose of the object model view matrix */layout(location = 0) out vec4 color;     /* output color */vec3 expand(vec3 v){    return (v - 0.5) * 2;}void main(){    // TBN matrix    vec3 T = normalize(mat3(u_MV) * normalize(fragTangent.xyz));    vec3 N = normalize(mat3(u_MV) * normalize(fragNormal.xyz));    vec3 B = normalize(cross(N, T));    mat3 TBN = mat3(T, B, N);        /* viewer direction in camera space */    vec3 mvEye = vec3(0, 0, 0);    vec3 mvPos = vec3(u_MV * pos);    vec3 mvViewDir = normalize(mvEye - mvPos);    /* light vector relative to fragment */    vec3 mvLightDir = normalize(u_mvLightPos - mvPos);        /* spotlight direction vector, here pointing to the center of the object */    //vec3 mvSourceDir = normalize(vec3(u_MV * vec4(0, 0, 0, 1) - vec4(u_mvLightPos, 1)));    vec3 mvSourceDir = normalize(u_mvSpotLightDir);    /* calculating lighting properties in camera space */    float d = distance(u_mvLightPos, mvPos);    float katt = 1 / (u_kc + u_kl * d + u_kq * d * d);    float kspot = pow(max(dot(-mvLightDir, mvSourceDir), 0), u_sexp);    /* calculating normal in camera space */    vec3 mvSurfaceNormal = normalize(vec3(u_invTransMV * vec4(fragNormal.xyz, 0)));    vec3 mvNormal;    if (u_hasBumpTexture)    {        vec3 bumpNormal = expand(texture(BumpTexture, fragTexCoord).xyz);        mvNormal = normalize(TBN * bumpNormal);    }    else        mvNormal = mvSurfaceNormal;    /* diffuse lighting in camera space */    float difIntensity = dot(mvNormal, mvLightDir) > 0 ? max(dot(mvNormal, mvLightDir), 0.0) : 0;    vec4 diffuse = vec4(difIntensity);    if (u_hasDiffuseTexture)        diffuse *= texture(DiffuseTexture, fragTexCoord);        /* ambient lighting */    vec4 ambient = vec4(1);    if (u_hasAmbientTexture)        ambient = texture(AmbientTexture, fragTexCoord);        /* specular lighting in camera space */    float specular = 0;    if (dot(mvNormal, mvLightDir) > 0)    {        vec3 refl = normalize(reflect(-mvLightDir, mvNormal));        specular = pow(max(dot(refl, mvLightDir), 0), u_mshi);    }    /* Set final pixel color */    color = globalLight;    if (dot(mvSurfaceNormal, mvViewDir) > 0)        color += (u_ka * ambient) + (u_kd * diffuse + u_ks * specular) * katt * kspot;    color.w = 1;};/*COMMENTS    1.  Light.z check (mvLightDir.z > 0?) was not done for the diffuse lighting and neither for the specular lighting,        because it was giving strange results on the sphere. Depending on the lighting of the sphere, there are        regions with LightDir.z < 0 that should receive light.*/